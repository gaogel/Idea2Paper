[
  {
    "review_id": "4d5fa3ee481b64df",
    "paper_id": "ARR_2022_10",
    "reviewer": null,
    "paper_summary": "The paper is essentially an exploration of the design space for seq2seq architectures that produce code from natural language. The paper explores the use of pretrained language models for the encoder as well as the use of an output vocabulary that guarantees grammatically valid code after a mapping is applied, but using Early parser actions as the output. The latter is one of the key contributions of the paper, allowing the comparison of different architectures with direct decoding into code and decoding into grammatical operations.\nThe paper is valuable as a replication and validation of previous work. It finds that the use of copying directly from the language input is the biggest contributor to performance, with grammatical outputs being another strong factor. ",
    "strengths": "This paper validates previous work and makes it clear which components are important to pay attention to when building a text to code model. This will be valuable guidance for future research and implementation. The paper has a detailed discussion of the different settings including a qualitative discussion (which unfortunately had to be moved into the appendix). The paper makes very good use of detailed examples to make it clear what is being done. ",
    "weaknesses": "- The number of datasets used is relatively small, to really access the importance of different design decisions, it would probably be good to use further datasets, e.g., the classical GeoQuery dataset.\n- I would have appreciated a discussion of the statistical properties of the results - with the given number of tests, what is the probability that differences are generated by random noise and does a regression on the different design decisions give us a better idea of the importance of the factors?\n- The paper mentions that a heuristic is used to identify variable names in the Django corpus, however, I could not find information on how this heuristic works. Another detail that was not clear to me is whether the BERT model was fine tuned and how the variable strings were incorporated into the BERT model (the paper mentions that they were added to the vocabulary, but not how). For a paper focused on determining what actually matters in building a text to code system, I think it is important to be precise on these details. ",
    "comments": "It would take some time to implement your task for other corpora, which potentially use different programming languages, but it might be possible to still strengthen your results using bootstrapping. You could resample some corpora from the existing two and see how stable your results are. \nIf you have some additional space, it would also be interesting to know if you have discuss results based on types of examples - e.g., do certain decisions make more of a difference if there are more variables?\nTypos: - Page 1: \"set of value\" -> \"set of values\" \"For instance, Orlanski and Gittens (2021) fine-tunes BART\" -> \"fine-tune\" - Page 2: \"Non determinism\" -> \"Non-Determinism\" ",
    "overall_score": "3 = Good: This paper is of interest to the *ACL audience and could be published, but might not be appropriate for a top-tier publication venue. It would likely be a strong paper in a suitable workshop.",
    "confidence": "4 = Quite sure. I tried to check the important points carefully. It's unlikely, though conceivable, that I missed something that should affect my ratings."
  }
]