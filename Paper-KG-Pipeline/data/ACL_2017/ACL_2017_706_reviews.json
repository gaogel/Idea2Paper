[
  {
    "review_id": "28b8caf6090f0f16",
    "paper_id": "ACL_2017_706",
    "reviewer": null,
    "paper_summary": "",
    "strengths": "- The paper is well written - It provides a compelling direction/solution to the problem of dealing with a large set of possible programs while learning natural language interfaces.",
    "weaknesses": "- The authors should discuss the effect of the incentives on the final performance ? Were other alternatives considered ?  - While the paper claims that the method can be extended to more practical domains, it is not clear to me how straightforward it is going to be. How sensitive is the method to the size of the vocabulary required in a domain ? \nWould increased ambiguity in natural language create new problems ? These questions are not discussed in the current experiments.\n- A real-world application would definitely strengthen the paper even more.",
    "comments": "",
    "overall_score": "4",
    "confidence": "4"
  },
  {
    "review_id": "517866d598284090",
    "paper_id": "ACL_2017_706",
    "reviewer": null,
    "paper_summary": "",
    "strengths": "This paper reports on an interesting project to enable people to design their own language for interacting with a computer program, in place of using a programming language. The specific construction that the authors focus on is the ability for people to make definitions. Very nicely, they can make recursive definitions to arrive at a very general way of giving a command. The example showing how the user could generate definitions to create a palm tree was motivating. The approach using learning of grammars to capture new cases seems like a good one.",
    "weaknesses": "This seems to be an extension of the ACL 2016 paper on a similar topic. It would be helpful to be more explicit about what is new in this paper over the old one.  There was not much comparison with previous work: no related work section.  The features for learning are interesting but it's not always clear how they would come into play. For example, it would be good to see an example of how the social features influenced the outcome. I did not otherwise see how people work together to create a language.",
    "comments": "",
    "overall_score": "4",
    "confidence": "4"
  },
  {
    "review_id": "985af28d94641cbc",
    "paper_id": "ACL_2017_706",
    "reviewer": null,
    "paper_summary": "",
    "strengths": "The ideas and the task addressed in this paper are beautiful and original. \nCombining indirect supervision (accepting the resulting parse) with direct supervision (giving a definition) makes it a particularly powerful way of interactively building a natural language interface to a programming language. \nThe proposed has a wide range of potential applications.",
    "weaknesses": "The paper has several typos and language errors and some text seems to be missing from the end of section 6. It could benefit from careful proofreading by a native English speaker.",
    "comments": "The paper presents a method for collaborative naturalization of a 'core' programming language by a community of users through incremental expansion of the syntax of the language. This expansion is performed interactively, whereby a user just types a command in the naturalized language, and then either selects through a list of candidate parses or provides a definition also in the natural language. The users give intuitive definitions using literals instead of variables (e.g. \"select orange\"), which makes this method applicable to non-programmers. \nA grammar is induced incrementally which is used to provide the candidate parses.\nI have read the authors' response.",
    "overall_score": "4",
    "confidence": "3"
  }
]